# Chapter 3 Integration Notes

> Technical implementation details for graphics integration on Quest 3

---

## Build System Changes

### CMake Shader Compilation

**Location**: [CMakeLists.txt](CMakeLists.txt)

The build system compiles GLSL shaders to SPIR-V during the CMake configure step:

```cmake
# Find glslc compiler (from Android NDK shader-tools)
file(GLOB_RECURSE GLSLC_EXECUTABLE "${ANDROID_NDK}/shader-tools/*/glslc*")

# Compile shaders
set(SHADER_SOURCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}")
set(SHADER_OUTPUT_DIR "${CMAKE_CURRENT_BINARY_DIR}/assets/shaders")

execute_process(
    COMMAND ${GLSLC_EXECUTABLE} -fshader-stage=vertex
        "${SHADER_SOURCE_DIR}/VertexShader.glsl"
        -o "${SHADER_OUTPUT_DIR}/VertexShader.spv"
)

execute_process(
    COMMAND ${GLSLC_EXECUTABLE} -fshader-stage=fragment
        "${SHADER_SOURCE_DIR}/PixelShader.glsl"
        -o "${SHADER_OUTPUT_DIR}/PixelShader.spv"
)
```

**Output location**: `$projectDir/.cxx/Debug/344h44l6/arm64-v8a/assets/shaders/*.spv`

### Gradle Asset Packaging

**Location**: [app/build.gradle:83-92](app/build.gradle)

Gradle sourceSets configuration includes compiled shaders in APK:

```gradle
sourceSets {
    main {
        assets {
            // Include shaders compiled by CMake (SPIR-V files)
            srcDirs += [
                "$projectDir/.cxx/Debug/344h44l6/arm64-v8a",
                "$projectDir/.cxx/Release/344h44l6/arm64-v8a"
            ]
        }
    }
}
```

**Critical**: The `344h44l6` hash is generated by Gradle based on build configuration. If it changes, this path must be updated.

### Build Dependency

**Location**: [app/build.gradle:106-112](app/build.gradle)

Ensures CMake builds before Gradle packages assets:

```gradle
afterEvaluate {
    tasks.matching { it.name.startsWith('merge') && it.name.endsWith('Assets') }.all { mergeTask ->
        mergeTask.dependsOn tasks.matching { it.name.startsWith('buildCMake') }
    }
}
```

This guarantees shaders are compiled before APK assembly.

---

## Quest 3 Adaptations

### Android Asset Manager Access

**Location**: [main.cpp:355-360](main.cpp)

The critical fix for shader loading on Android:

```cpp
#if defined(__ANDROID__)
    // Get AAssetManager through JNI (androidApp->activity->assetManager doesn't exist)
    JNIEnv *env;
    androidApp->activity->vm->AttachCurrentThread(&env, nullptr);
    jobject javaAssetManager = env->CallObjectMethod(androidApp->activity->clazz,
        env->GetMethodID(env->GetObjectClass(androidApp->activity->clazz),
        "getAssets", "()Landroid/content/res/AssetManager;"));
    AAssetManager *assetManager = AAssetManager_fromJava(env, javaAssetManager);
#endif
```

**Why this is needed**:
- `android_app` struct does NOT have a direct `assetManager` field
- Must use JNI to call `Activity.getAssets()` from native code
- This was the root cause of the initial SIGSEGV crash

### Manifest Configuration

**Location**: [app/src/main/AndroidManifest.xml](app/src/main/AndroidManifest.xml)

The minimal working configuration for Quest 3:

```xml
<!-- Quest metadata: Hand tracking support -->
<meta-data android:name="com.oculus.handtracking.frequency" android:value="HIGH" />
<meta-data android:name="com.oculus.handtracking.version" android:value="V2.0" />

<!-- Supported devices -->
<meta-data android:name="com.oculus.supportedDevices" android:value="quest3|quest2|questpro" />
```

**What was removed** (caused controller popup):
- ❌ `com.oculus.vr.focusaware` metadata
- ❌ `com.oculus.handtracking.enabled` metadata
- ❌ `com.oculus.permission.HAND_TRACKING` permission

**Key insight**: Chapter 1/2 already solved this - Chapter 3 initially had extra metadata that triggered the controller requirement.

### Shader Loading Paths

**Android**:
```cpp
std::vector<char> vertexSPIRV = ReadBinaryFile("shaders/VertexShader.spv", assetManager);
std::vector<char> pixelSPIRV = ReadBinaryFile("shaders/PixelShader.spv", assetManager);
```

**Desktop** (not tested in this tutorial):
```cpp
std::vector<char> vertexSPIRV = ReadBinaryFile("VertexShader.spv");
std::vector<char> pixelSPIRV = ReadBinaryFile("PixelShader.spv");
```

---

## Shader Compilation Process

### Source: GLSL

**VertexShader.glsl**:
- Input: vertex position, color, MVP matrix (via push constants)
- Output: transformed gl_Position, interpolated color

**PixelShader.glsl**:
- Input: interpolated vertex color, view index (via push constants)
- Output: color with per-eye tint (cyan for left, magenta for right)

### Compilation: glslc

```bash
glslc -fshader-stage=vertex VertexShader.glsl -o VertexShader.spv
glslc -fshader-stage=fragment PixelShader.glsl -o PixelShader.spv
```

**Compiler location**: `$ANDROID_NDK_HOME/shader-tools/windows-x86_64/glslc.exe`

**Output format**: SPIR-V binary (Vulkan bytecode)

### Runtime: Vulkan Shader Modules

**Location**: [GraphicsAPI_Vulkan.cpp](GraphicsAPI_Vulkan.cpp) (exact line TBD)

```cpp
VkShaderModuleCreateInfo vertexShaderCreateInfo{VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO};
vertexShaderCreateInfo.codeSize = vertexSPIRV.size();
vertexShaderCreateInfo.pCode = reinterpret_cast<const uint32_t *>(vertexSPIRV.data());
vkCreateShaderModule(m_vkDevice, &vertexShaderCreateInfo, nullptr, &m_vertexShaderModule);
```

**Lifecycle**:
1. CMake runs glslc → .spv files
2. Gradle packages .spv → APK assets
3. App loads .spv via AAssetManager → memory buffer
4. Vulkan creates shader modules → GPU executable

---

## Swapchain Format Selection

### OpenXR Enumeration

**Location**: [GraphicsAPI_Vulkan.cpp](GraphicsAPI_Vulkan.cpp) (CreateSwapchains method)

```cpp
uint32_t swapchainFormatCount = 0;
xrEnumerateSwapchainFormats(m_session, 0, &swapchainFormatCount, nullptr);
std::vector<int64_t> swapchainFormats(swapchainFormatCount);
xrEnumerateSwapchainFormats(m_session, swapchainFormatCount, &swapchainFormatCount, swapchainFormats.data());
```

### Format Selection Strategy

**Preferred formats** (in order):
1. `VK_FORMAT_R8G8B8A8_SRGB` - sRGB color space (Quest native)
2. `VK_FORMAT_B8G8R8A8_SRGB` - alternative sRGB format
3. Fallback to first format returned by runtime

**Why sRGB matters**:
- Quest displays are sRGB
- Incorrect format → washed out colors or incorrect gamma
- OpenXR runtime (Oculus) typically provides sRGB formats first

### Swapchain Creation

**Per-eye swapchains**:
```cpp
for (size_t i = 0; i < m_viewConfigurationViews.size(); i++) {
    SwapchainInfo swapchainInfo;
    XrSwapchainCreateInfo swapchainCreateInfo{XR_TYPE_SWAPCHAIN_CREATE_INFO};
    swapchainCreateInfo.usageFlags = XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT;
    swapchainCreateInfo.format = m_colorSwapchainFormat;
    swapchainCreateInfo.width = m_viewConfigurationViews[i].recommendedImageRectWidth;
    swapchainCreateInfo.height = m_viewConfigurationViews[i].recommendedImageRectHeight;
    // ...
    xrCreateSwapchain(m_session, &swapchainCreateInfo, &swapchainInfo.swapchain);
}
```

**Key parameters**:
- `width/height`: Recommended by OpenXR (typically 1832x1920 per eye on Quest 3)
- `arraySize`: 1 (not using texture arrays for multiview)
- `mipCount`: 1 (no mipmaps for swapchain images)
- `sampleCount`: 1 (no MSAA at swapchain level)

---

## Vulkan Rendering Considerations

### Synchronization

**Swapchain image acquisition**:
```cpp
XrSwapchainImageAcquireInfo acquireInfo{XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO};
xrAcquireSwapchainImage(swapchainInfo.swapchain, &acquireInfo, &imageIndex);

XrSwapchainImageWaitInfo waitInfo{XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO};
waitInfo.timeout = XR_INFINITE_DURATION;
xrWaitSwapchainImage(swapchainInfo.swapchain, &waitInfo);
```

**Critical**: MUST wait for image before rendering, release after rendering complete.

### Projection Layer Setup

**Location**: [main.cpp](main.cpp) (RenderFrame method)

```cpp
for (uint32_t i = 0; i < viewCount; i++) {
    projectionLayerViews[i] = {XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW};
    projectionLayerViews[i].pose = views[i].pose;
    projectionLayerViews[i].fov = views[i].fov;
    projectionLayerViews[i].subImage.swapchain = m_colorSwapchains[i].swapchain;
    projectionLayerViews[i].subImage.imageRect.offset = {0, 0};
    projectionLayerViews[i].subImage.imageRect.extent = {
        (int32_t)m_viewConfigurationViews[i].recommendedImageRectWidth,
        (int32_t)m_viewConfigurationViews[i].recommendedImageRectHeight
    };
}
```

**Per-view state**:
- `pose`: Eye position/orientation in reference space
- `fov`: Asymmetric field of view (accounts for lens distortion)
- `subImage`: Which swapchain image and region to composite

### Rendering Pipeline

1. **xrWaitFrame** → Get predicted display time
2. **xrBeginFrame** → Signal frame start
3. **xrLocateViews** → Get updated eye poses and FOVs
4. **For each eye**:
   - Acquire swapchain image
   - Wait for image availability
   - Render scene with per-eye projection matrix
   - Release swapchain image
5. **xrEndFrame** → Submit projection layers for composition

---

## Known Differences from Original Tutorial

### 1. Asset Loading

**Original**: Uses desktop file I/O (`fopen`, `std::ifstream`)

**This version**: Uses Android AAssetManager API

**Impact**: Requires JNI bridge to get AAssetManager from Activity

### 2. Shader Paths

**Original**: Shaders in executable directory

**This version**: Shaders in APK `assets/shaders/` subdirectory

**Impact**: Different paths for `ReadBinaryFile()` calls

### 3. Build System

**Original**: CMake + desktop toolchain

**This version**: CMake + Android Gradle Plugin + NDK toolchain

**Impact**: Complex dependency tracking between CMake shader compilation and Gradle asset packaging

### 4. Platform-Specific Code Paths

**Original**: Minimal platform ifdefs

**This version**: Extensive `#if defined(__ANDROID__)` blocks for:
- Asset loading
- JNI integration
- Logging (uses `__android_log_print` instead of `std::cout`)

### 5. Testing Workflow

**Original**: Desktop debugging, standard debugger

**This version**: On-device testing, ADB logcat, automated test scripts

**Impact**: Slower iteration cycle, different debugging tools

---

## Verification Checklist

When making changes to Chapter 3, verify:

- [ ] **Shaders compile**: Check CMake output for glslc success
- [ ] **Shaders in APK**: Run `7z l app-vulkan-debug.apk | findstr .spv`
- [ ] **App launches**: No controller popup, no immediate crash
- [ ] **Logs appear**: `adb logcat -s openxr_tutorial:*` shows initialization
- [ ] **Graphics render**: Cubes visible in headset with stereo color tint
- [ ] **No validation errors**: Check for Vulkan validation layer warnings
- [ ] **Swapchain images**: `xrEnumerateSwapchainImages` returns expected count
- [ ] **Frame loop stable**: No dropped frames, smooth 72/90Hz rendering

---

## Debug Tips

### Shader Compilation Issues

```batch
REM Manually compile shaders
cd samples\openxr-tutorial\chapter3
%ANDROID_NDK_HOME%\shader-tools\windows-x86_64\glslc.exe -fshader-stage=vertex VertexShader.glsl -o VertexShader.spv
%ANDROID_NDK_HOME%\shader-tools\windows-x86_64\glslc.exe -fshader-stage=fragment PixelShader.glsl -o PixelShader.spv
```

### Asset Packaging Issues

```batch
REM Check shader output directory
dir .cxx\Debug\344h44l6\arm64-v8a\assets\shaders

REM Verify shaders in APK
"C:\Program Files\7-Zip\7z.exe" l app\build\outputs\apk\vulkan\debug\app-vulkan-debug.apk | findstr assets
```

### Runtime Shader Loading Issues

```batch
REM Full logcat with file I/O
adb logcat -s openxr_tutorial:* DEBUG:* *:E

REM Watch for AAssetManager errors
adb logcat | findstr -i "asset"
```

### Vulkan Validation

```batch
REM Enable validation layers (if available in Debug build)
adb logcat -s openxr_tutorial:* VK-*:*
```

---

## Performance Notes

### Quest 3 Rendering Specs

- **Resolution**: 1832x1920 per eye (recommended)
- **Refresh Rate**: 72Hz (default), 90Hz (if enabled)
- **GPU**: Qualcomm Adreno 740
- **Vulkan Version**: 1.3.x (supports Vulkan 1.0.3 required by app)

### Optimization Opportunities (Future Chapters)

1. **Multiview rendering**: Use `VK_KHR_multiview` for single-pass stereo
2. **Foveated rendering**: Use Quest's fixed foveated rendering APIs
3. **Texture compression**: Use ASTC for reduced memory bandwidth
4. **Occlusion culling**: Skip rendering objects outside FOV
5. **Dynamic resolution**: Adjust render resolution based on GPU load

---

## References

- **OpenXR Swapchains**: https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#swapchains
- **Vulkan on Android**: https://developer.android.com/ndk/guides/graphics/getting-started
- **Quest Graphics Best Practices**: https://developer.oculus.com/documentation/native/android/mobile-best-practices-graphics/
- **AAssetManager API**: https://developer.android.com/ndk/reference/group/asset

---

**Documentation Version**: 1.0
**Created**: 2025-12-07
**Target**: Meta Quest 3 (Vulkan 1.0.3+, OpenXR 1.0.34)
